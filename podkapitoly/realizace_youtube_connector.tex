\section{Realizace YouTube konektoru}
\section{Řešení spolupráce s YouTube API}
\subsection{YouTube Data API (v3)}
\par Tato část rozhraní umožňuje začlenění funkcí YouTube do vlastní aplikace. Proto jí používám pro získání metadat. Nejprve jsem si musel vytvořit google účet a zaregistrovat aplikaci. Pro tento krok slouží \url{https://console.developers.google.com/project}. Každý takto vytvořený projekt má u sebe statistiky s počtem dotazů, počtem chyb, identifikačním řetězcem a názvem. 
\par Po kliknutí na název mého projektu je možné se dozvědět podrobnější informace a změnit konfiguraci projektu. Základní náhled mi poskytuje graf s počtem požadavků, kde vidím jak moc vytěžuji YouTube API. Dále je zde potřeba nechat si vygenerovat unikátní API klíč, pomocí kterého získávám metadata.
\par Vlastní implementace je napsaná v jazyce Ruby a vývojovém prostředí RubyMine. Pro vyřešení metadat jsem si vytvořil jednu třídu, kterou jsem napojil na narra-core. 
\begin{minted}{ruby}
require 'narra/spi'

module Narra
  module Youtube
    class Connector < Narra::SPI::Connector
\end{minted}
\par Tímto kusem kódu jsem vytvořil nový modul, který je potomkem Narra::SPI::Connector. Další věc jsem musel řešit validaci url. V případě nevalidní url mi stačilo vrátit false, při úspěchu jsem vracel true. Nejdřívě jsem zkoušel do projektu zakomponovat metodu match. Ta ovšem vracela string místo booleovké hodnoty a proto jsem ji musel nahradit =~. Takto zkonstruovaný výraz by ovšem nefungoval úplně dokonale, neboť při funkční url by vrátil 0. Stačilo výraz lehce poupravit do tvaru !!(url =~ RegExp ) a vše fungovalo jak má.
\begin{minted}{ruby}
!!(url =~ /^(http:\/\/|https:\/\/)?(www\.)?(youtube\.[A-Za-z\.]+
|youtu.be\.)\/(watch\?v=)?[A-Za-z0-9\-_]{6,12}(&[A-Za-z0-9\-_]+)
*=?.*\$/)
\end{minted}
\par Pro vytažení dat z YouTube jsem použil YouTube API v3, konkrétněji adresu \url{https://www.googleapis.com/youtube/v3/videos?id=#{@videoid}&key=můj\_klíč&part=část}, můj\_klíč je vygenerovaný API klíč a část je požadovaná návratová hodnota z YouTube API. Mezi tyto hodnoty patří:
\begin{itemize} 
\item{snippet}
\item{contentDetails}
\item{fileDetails}
\item{player}
\item{processingDetails}
\item{recordingDetails}
\item{statistics}
\item{status}
\item{suggestions}
\item{topicDetails}
\end{itemize}
\par Použil jsem jen čtyři položky. Snippet, který napíše o videu většinu informací. ContentDetails byl potřeba pro splnění pořadavků z DublinCore, statistics přidají do obsahu počty sledovaností a status zobrazí licenci a informace o sdílení videa. Tyto čtyři položky stačí pro pořadovaná metadata zadavatelem a při přidání dalších bych zbytečně omezoval maximální počet vrácených položek díky omezení YouTube API.

\par Po validaci url jsem musel vytvořit oddělenou metodu pro jméno videa, které je v json objektu reprezentuje title. Nejdřívě jsem zkoumal řešení pomocí již hotového json parseru, což by bylo možná jednodušší, ale poté vyhrála možnost zápisu na dva řádky.
\begin{minted}{ruby}
pom = @youtube_json_object_snippet.split('"title": "')[1]
@name = pom.split("\",\n")[0]
\end{minted}
\par Metoda split vytvoří z objektu pole, kde je velmi jednoduché se pomocí příslušného indexu dostat k požadované hodnotě. Rozdělení pomocí \verb|\|",\verb|\|n" je naprosto v pořádku, neboť když někdo zkusí zadat například do popisku videa \verb|\|",\verb|\|n tento žetězec YouTube z něj udělá \verb|\|\verb|\|",\verb|\|\verb|\|n a proto nemůže dojít ke špatnému rozdělení v důsledku špatné sekvence znaků v popiscích. 