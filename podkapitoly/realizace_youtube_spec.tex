\section{Testování YouTube konektoru}
\subsection{Teorie testování}
\par Pro správné pochopení teorie testování\cite{si1} si musíme uvědomit, že pomocí testů prokážeme že software obsahuje chyby při nesplnění testu. Při splnění všech testů nemůžeme dokázat, že je software stoprocentně bez chyb, neboť může existovat chyba, kterou testy neodhalily. Proto je potřeba se důkladně věnovat testování, abychom snížili riziko chyby na nejnižší možnou úroveň.
\subsection{Jednotkové testy}
\par První druh testů jsou jednotkové testy\cite{si1}. Ty se zabývají konkrétní funkčností jednotlivých metod a tříd. Testování probíhá pro jednu konkrétní třídu, obvykle běží krátkou dobu a testování probíhá na lokálním počítači vývojáře. Tyto testy pokrývá v Ruby nástroj RSpec, který jsem popsal na začátku práce. V mých testech jsem se zaměřil na zjištění správné odezvy metod a získání správných výsledků.
\subsection{Integrační testy}
\par Integrační testování\cite{si1} se provádí po dokončení jednotkových testů a slouží k bezchybnému začlenění nového kusu aplikace do stávajícího projektu. Těmito testy se ověřuje nejen integrace komponentů, ale i spolupráce se softwarem případně hardwarem při složitějších projektech, které potřebují specifický hardware nebo software. Testování probíhá začleněním jedné z komponent a postupném přidávání dalších komponent k celému projektu. Integrační testování je často zanedbáváno díky rozpočtu projektu. Takto nezachycené chyby se ovšem projeví v dalších testech a je proto dobré integrační testy nepřeskočit.
\subsection{Systémové testy}
\par V pořadí již třetí zkouška funkčnosti projektu se zabývá chováním celého projektu jako celku. Provádí se zde simulace scénářů a kroků, které mohou po nasazení projektu nastat. Je to poslední testování před předáním projektu zákazníkovi a proto obvykle probíhá několikrát. Systémové testování\cite{si1} je nezbytné pro výstupní kontrolu projektu.
\subsection{Akceptační testy}
\par Akceptační testy jsou prováděné zákazníkem spolu se zástupcem firmy na předem dohodnutých scénářích. Jedná se o otestování, zda zadavatel správně pochopil požadavky zákazníka. Odhalení závažných nedostatků v této poslední fázi bývá nejhorším možným scénářem pro vývojáře, který musí následně aplikaci předělávat. Můj gem jsem testoval jednotkovými a integračními testy, neboť systémové a akceptační testování zajišťují programátoři jádra projektu.


\subsection{Testování třídy Connector}
\subsubsection{Testování URL}
\par První část testu kontroluje vytváření a validaci URL. Před první částí testů jsem si nastavil testovanou URL a zjistil zda se správně vytvoří objekt dané třídy. Poté jsem zkontroloval tři globální proměnné, zda se nezměnil jejich obsah. Tyto dva testy zajistili primární funkčnost konektoru a mohl jsem zkontrolovat konkrétní URL. Zde jsem hledal různé URL adresy, které nikam nepřesměrují a jsou validní. Dále jsem potřeboval najít nevalidní URL, přičemž stačilo vhodným způsobem modifikovat URL validní. Dále jsem potřeboval najít URL, která se přesměruje na validní. Zde jsem použil funkci YouTube, kde je možné zvolit sdílení videa, což vytvoří zkrácenou URL, která se přesměruje. Poté jsem ještě použil Google zkracovač, což je také velmi dobrá metoda pro ověření validace a přesměrování. \note{Mnoho informací v jednom odstavci, zkus to nějak rozdělit.}
\subsubsection{Testování objektu konektoru}
\par Další testy již probíhaly pro určitý objekt konektoru. Zde jsem opět našel několik YouTube videí na kterých jsem testoval příslušná metadata. Pro hezčí zápis testu jsem chtěl zápis metadat převést z formátu \textit{\{name:'channelId', value:'\#\{@channelId\}'\}} do formátu \textit{\{'channelId'=>'\#\{@channelId\}'\}}, což mi umožnilo lepší a přehlednější přístup k testování metadat. Url adresy jsem volil pro pokrytí speciálních znaků v popiscích, pro neobvyklá metadata, které jsou u videí jen zřídka a pro pokrytí všech metadat. Zde byl problém s proměnlivými statistikami u videa, kde například u počtu shlédnutí jsem musel při testování stále upravovat testovanou hodnotu. Proto jsem vizuálně otestoval s JSON objektem shodu v proměnlivých počtech u statistik a poté jsem test zakomentoval. Tento problém bych mohl vyřešit nastavením intervalu, což také není úplně nejlepší neboť bych se musel znovu podívat zda je to číslo opravdu dobře nebo ne.
\par V nástroji RSpec je v bloku \texttt{before} několik možností parametrů v závorkách. V první části testování, kdy jsem měl ještě málo testů, trval celý blok okolo deseti vteřin. V závěrečné fázi práce, kdy jsem otestoval vše co mě napadlo trval test i přes jednu minutu. Takto dlouhé testování se mi nezdálo a proto jsem se důkladně zaměřil na parametrizaci v bloku \texttt{before}. Při parametru \texttt{:each}, který jsem měl ze začátku se celá inicializace provedla před každým blokem it, proto testy trvaly tak dlouhou dobu. Po změně na \texttt{:all} se rázem čas testů dostal stabilně pod deset vteřin. Proto je potřeba dávat velký pozor, zda neděláme v testu stejné věci zbytečně vícekrát.
\subsubsection{Testy na videích}
\par Pro první testované video jsem zvolil \uv{Zimní montáže - 1. díl} z kanálu mrk.cz. Zde byl zajímavý prvek ve formě odřádkování v popisu videa. Druhé testované video bylo znovu v duchu rybolovu s zajímavým popiskem, který byl tentokrát prázdný. Dále jsem chtěl na druhém videu otestovat živé vysílání neboť toto video bylo vysíláno živě a přesto je parametr \texttt{liveBroadcastContent} roven hodnotě \texttt{false}. Hodnota false byla v metadatech o videu správně, neboť po živém odvysílání video změní svůj stav a není vysíláno živě.
\par Dále jsem vytvořil jeden test pro otestování titulků. Zde jsem potřeboval ověřit, zda mi program správě vyhodí výjimku při neexistujících titulcích. Tato výjimka je velmi opodstatněná, neboť každý download titulků stojí 200 jednotek z YouTube API kvóty a bylo by nežádoucí nechat uživatele několikrát zkusit stáhnout neexistující titulky. Další test spočíval ve správném zpracování dlouhé URL adresy, obsahující další informace za identifikátorem videa, pomocí regulárního výrazu při validaci URL a pro zkoušku vytažení všech dostupných dat.
\par Páté testované video bylo vytvořeno kvůli možnosti stáhnout validní titulky k videu. Další test vyzkoušel časovou známku u titulků pro čas vytvoření. Blok \uv{should check download video} měl na starost otestování možnosti stáhnout video, neboli dostat se na URL, která obsahuje pouze video stream. Tento test jsem nemohl provést, neboť potřebuji proměnnou prostředí, kterou dostanu až při dotazu na server. Předposlední test znovu zkusil stažení titulků a ověření, zda bude vyhozena výjimka u neexistujících titulků. Závěrečný test je zde z důvodu omezení videí v různých zemích. Zde YouTube předává hodnotu blockedIn v případě, že je video zakázáno v nějaké zemi. Seznam zemí dále vrátí pomocí pole. V případě, že video není nikde blokováno tento atribut zmizí, protože v databázi nemohou být prázdné hodnoty. Znovu jsem proto musel otestovat správné reagování na omezení.
\subsubsection{Shrnutí jednotkových testů}
\par V jednotkových testech jsem se snažil pokrýt všechny možné nástrahy, které mi je schopen uživatel nadělit a otestovat, zda můj program reaguje podle předpokladů. Všechny testy proběhly bez chyb a proto jsem snížil pravděpodobnost, že moje rozšíření obsahuje chyby na přijatelnou úroveň. S otestovaným softwarem pomocí jednotkových testů mohu pokračovat v integračních a systémových testech s mateřskou aplikací.
\subsection{Integrační testy}
\par Integrační testování odhalilo několik ošetření, které je potřeba provádět v mém balíčku a nespoléhat na jádro aplikace. Jednalo se o zařazení metadat, která by měla hodnotu nil, nebo prázdný řetězec. V takovém případě jsem nesměl přidat danou položku s metadaty k výslednému videu, neboť ošetřování obsahu metadat při zpracovávání videa by bylo v rozporu s modelem. Další chybu integrační testy neodhalily a má část aplikace funguje dle očekávání.